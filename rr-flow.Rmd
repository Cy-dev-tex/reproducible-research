---
title             : "A Reproducible Data Analysis Workflow with RMarkdown, Git, Make & Docker"
shorttitle        : "Reproducible Data Analysis Workflow"

author: 
  - name          : "Aaron Peikert"
    affiliation   : "1,2"
  - name          : "Andreas Brandmaier"
    affiliation   : "1,3"
    corresponding : yes    # Define only one corresponding author
    address       : "Max Planck Institute for Human Development, Lentzeallee 94, 14195 Berlin, Germany"
    email         : "brandmaier@mpib-berlin.mpg.de"

affiliation:
  - id            : "1"
    institution   : "Center for Lifespan Psychology, Max Planck Institute for Human Development, Berlin, Germany"
  - id            : "2"
    institution   : "Humboldt-Universit√§t zu Berlin"
  - id            : "3"
    institution   : "Max Planck UCL Centre for Computational Psychiatry and Ageing Research, Berlin, Germany & London, U.K." 

authornote: |

abstract: "`r readr::read_file('abstract.Rmd')`"

keywords          : "keywords"
wordcount         : "`r wordcountaddin::word_count(here::here('rr-flow.Rmd'))`"

bibliography      : ["reproducible-research.bib"]

floatsintext      : yes
figurelist        : no
tablelist         : no
footnotelist      : no
linenumbers       : no
mask              : no
draft             : no

documentclass     : "apa6"
classoption       : "man"
output            : papaja::apa6_pdf
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
if(!require("pacman"))install.packages("pacman")
pacman::p_load("here", "tidyverse")

knitr::read_chunk(here("R", "random.R"))
```

! TODO - Unterschied zwischen computational, empirical, and statistical reproducibility (cf. Stodden et al., 2014)


Literate Programming
: Interwoven text and computer code that together forms a human-readable document.
: Example: One document that includes text that describes a statistical test, code that is used to execute the statistical and the output of the code in the same document.

Version Control
: The management of change of documents/code.
: Example: Changes from the manuscript text upon request by the reviewer are identifiable. 

Dependency Tracking
: How different parts of a manuscript/analysis relate and how these dependencies resolve via execution of code.
: Example: The manuscript depends on the statistical analysis, which depends on the data.

Containerization
: A virtual computational environment that does encapsulate all needed software. More formally called operating-system-level virtualization.
: Example: A statistical analysis depends on the used statistical software and a virtual machine bundles them together.

The scientific community widely recognizes that these tools enhance reproducibility, and provides guidelines for their use (Literate Programming: @ruleTenSimpleRules2019; Version Control: @barbaHardRoadReproducibility2016; Dependency Management: @askrenUsingMakeReproducible2016; Containerization: @clyburne-sherinComputationalReproducibilityContainers2018). However, only a workflow using them in unison allows confidence in reproducing a scientific report. Within the community of users of the R Programming Language for each purpose, a specific software solution is the most popular. For literate programming, `rmarkdown`, for version control `git`, for dependency management `make` and for container `docker`. Each of them serves a meta-scientific valuable goal (reproducibility) and increases the productivity of the researcher. Each of these software solutions is highly flexible and powerful, so to master them thoroughly often years of practice are required. Luckily the researcher can learn the minimal valuable subset needed to ensure reproducibility with little practice.

We believe that for sufficient chances of reproducibility, proper documentation is crucial since it answers the question "What steps have to be taken to reproduce the results?". The most precise documentation is computer code, and the most productive computer code is code that runs automatically without human interaction. These principles are what guides the use of `rmarkdown`, `git`, `make`, `docker`.

The first step towards long-term reproducibility is to have an R-script or R-markdown, that runs on a local computer without error. A process, we assume, that is familiar to the reader. A next step is to make sure that all files relevant for the analysis can be moved to another computer. To this end, it is essential that all files are within one folder (or, subfolders within it) and all paths are relative to that folder. A robust solution to the problem of making sure that file access does not break across computing platforms are [Rstudio Projects](https://r4ds.had.co.nz/workflow-projects.html) and the `here` package.

```{r, eval=FALSE}
# BAD
iris <- read.csv("/home/aaron/Documents/reproducible-research/data/iris.csv")
# GOOD
iris <- read.csv("data/iris.csv")
# BETTER
iris <- read.csv(here("data", "iris.csv"))
```

This folder, where everything resides that you need for analysis (code and data), is referred to as a Project. Working with Projects is exceptionally comfortable with RStudio an integrated development environment (IDE) for R. It is usefull to organize this Project in way that strictly segregates (raw) data and code by placing them in directories called `data` and `R` [see Section 4 @marwickPackagingDataAnalytical2018].

Sometimes external requirements mean that the data cannot be stored and shared together with the scripts. In most of the cases we have seen, these are either space constraints or privacy considerations. In these cases, of course, unrestricted reproducibility is not guaranteed. If this way of dividing data and scripts into different databases is unavoidable, we recommend that you crosscheck using checksums before loading data. To do this, a checksum must be created and filed at the time of the original analysis, and at the time of reproduction the current checksum must be compared with the stored checksum (also called a "hash", e.g., using the functions provided in package `digest`).

```{r}
x <- data.frame(VAR1=c(1,2,3,4),VAR2=c(0,4,6,9) )
digest::sha1(x)
```

Reproducibility at a basic level assumes that results are the same if neither script nor data have changed. It is often not trivial to find out whether anything has changed and if so to "go back in time." `git` enables you to do both. A good mental model for `git` is that it takes a sequence of snapshots of all files it is supposed to track. In the language of git, these snapshots are "commits".  A commit represents a complete copy of the state of the files when added to a commit. Each commit has a unique identifier (a hash). Going back to one state is as easy as finding the hash of the commit. Finding a specific hash can be made even easier by tagging specific commits, e.g., as "submission," "preprint," "publication." This collection of commits is called "repository," which is almost the same as your Project.

A typical git workflow looks like that:

```{bash, eval=FALSE}
git init # to initialize git
git add /data/iris.csv /R/analysis.R # track specific files/changes
git commit -m "add data & analysis" # take snapshot
# new data comes in
git commit -a -m "complete data colections" # add (-a) and comit all changes
```

So to keep track of all changes, you only need to use `git add` & `git commit` or `git commit -a` to do both. These commands need to be executed in the `terminal`, which you can access from within Rstudio (`Shift + Alt + R`).  Rstudio also offers a graphical user interface for Git and quite likely this suffice for almost every interaction with Git.

![Git Pane in RStudio](Images/git-pane.png)

Now one can check everything that has happened (`git log`) and look at the exact state by supplying the id of the commit or the first few digits of it to `git checkout`:

```{bash, eval = FALSE}
git log
git checkout 77db06f78e
```

Git also makes it especially easy to share and collaborate on a project with another researcher. A popular service for sharing via git is [Github](https://github.com). Just sharing Git repositories with the public is always free, private repositories (only visible to persons you invite) are [free for researcher](https://help.github.com/en/articles/applying-for-an-educator-or-researcher-discount). After creating a user account, you can create a new repository where Github advises you how to upload your repository from the terminal e.g., for this repository:

```{bash, eval=FALSE}
git remote add origin git@github.com:aaronpeikert/reproducible-research.git
git push -u origin master
```

`git push` or the green up arrow in the git pane uploads local updates. To download this git repo to another computer type into the terminal:

```{bash, eval=FALSE}
git clone git@github.com:aaronpeikert/reproducible-research.git
```

Git and Github can do even more to help you to collaborate with your fellow researcher, such as formal means to track issues and their status (open/closed/resolved) and further means to managing and merging multiple, parallel versions of code (such as branches, pull requests, merges) but this is beyond the already broad scope of this tutorial. Another benefit of using Git and Github is that experimentation is highly encouraged since you can go back to any state quickly and even when you lose access to the file on your computer, everything is backed up on the Github servers.

Even when you have obtained a version of the Project, and you can ensure that this version is unchanged, you may not know how to reproduce the results, because it is unclear what has to be run in which order. This job gets comfortable with `make`, since it allows you to create (computational) recipes too (re-)create files. A downside of `make` is, that the installation on Windows is not straightforward. However, if `docker` (see later sections) is available this is not an issue, since `make` ships with (almost) every `docker` image.

A `Makefile` obeys the following scheme:

```
target: dependency1 dependency2
  command-to-create-target
```

A typical `Makefile` might look like:

```
analysis.pdf: data/clean.csv
  Rscript -e 'rmarkdown::render("analysis.Rmd")'

data/clean.csv: R/clean.R data/iris.csv
  Rscript -e 'source("R/clean.R")'
```

The first line reads: to create `analysis.pdf` the `analysis.Rmd` needs to be rendered, which depends on `data/clean.csv`. This dependency is itself a target. To create `data/clean.csv`, `R/clean.R` and `data/iris.csv` are needed. If you type `make analysis.pdf` `make` first checks whether the dependencies do exist and if not whether or it knows how to create them. So if `data/clean.csv` does not exist, `make` creates it. The same thing happens if one of the dependencies of a target is newer then the target itself, then updates everything that directly or indirectly depends on it. So if `data\iris.csv` is newer then `data\clean.csv`, make attempts to recreate `data\clean.csv` and `analysis.pdf`. If there is a dependency which is missing, and there is no recipe to make it, `make` stops with an error. It is a convention to have a target `all` which depends on everything and make it the first target in a `Makefile`, then the command `make` without any argument automatically creates everything. The button `Build All` from within RStudio also triggers this process.

```
all: analysis.pdf
```

![Build Pane in RStudio](Images/build-pane.png)

If you have followed the above workflow, a fellow researcher is three commands away from fully reproducing your analysis:

```{bash, eval=FALSE}
git clone https://github.com/sirfisher/iris.git
cd iris
make all
```

However, this relies on the crucial assumption that your computational environments are sufficiently compatible, e.g., everything needed is installed (R + Packages) at a compatible version of the software.

`docker` is a tool that allows to precisely state what computational environment an analysis relies on and recreates this environment automatically on most operating systems (Windows, OS X & Linux). `docker` does that, by setting up a virtual computer on which it executes a series of commands (e.g., installing software). It then saves the resulting state of the virtual computer in what is called an "image." This image can be started and execute commands, e.g., running an R-script or `make`. A running instance of an image is called a container. An image can be transferred and executed on any machine that has docker installed. Unregarding the machine executing the container, from the perspective of a program running inside the container, it always looks identical. There are essential differences to a traditional virtual machine, but thinking about a docker container as a computer running inside your computer is still a plausible mental model. The most important advantage over traditional virtual machines is that container are lightweight, meaning they start fast and don't need much storage. Docker achieves that by reusing large parts of the hosts operating system (how much is varying widely between Linux, OS X & Windows).

While the R programming language is considered stable and much effort is put into backward compatibility, sometimes even basic functions like `sample()` change their behavior from one version to another.

Consider the following R-code:

```{r,eval=FALSE}
set.seed(1234)
sample(1:10, 5)
```

The usual expectation is that this code delivers the same pseudo-random five numbers regardless of the operating system or R-Version (due to `set.seed()`). Using docker, we can start an image which contains the R-Version 3.5.0, and execute the code there.

```{r random, eval=FALSE}
```

```{r, child="R/random35.md"}
```

Surprisingly in an image with a more recent version of R (3.6.0), this results in another sample:

```{r random, eval=FALSE}
```

```{r, child="R/random36.md"}
```

Note that this is the intended behavior and the result of a [bugfix](https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17494) in the random number generator implemented from R 3.6.0 upwards.

Such change prevents many reports from beeing replicated, if they contain, e.g., multiple imputations, bootstrapping, simulations studies, graphics with random jitter, Bayesian estimations using sampling algorithms (such as Markov Chain Monte Carlo), or similar technics which involve random sampling. However only rarelydoes an analysis depend only on base R, often a considerable number of packages is required, and they will most likely more often introduce breaking changes with updates. The whole endeavor of reproducibility is therefore at stake, every time an update is rolled out. To ensure long-term reproducibility, `docker` replicates the original computational environment of an analysis exactly. However, we do not intend to advocate that software should not be updated; updates typically promote bugfixes and provide new functionality; but full computational reproducibility is only achieved if the originally used software version(s) are documented. Among other things, this allows to trace back recent updates as to what change in what software caused a non-replication of the original results. Quite to the contrary with solutions like docker, it gets more comfortable than ever to safely update to new versions, by just bumping the R Version number of the docker image.

This convenience is possible to the efforts of the [rocker project](https://github.com/rocker-org/rocker) [@boettigerIntroductionRockerDocker2017a] which provides docker images preconfigured with an R-installation of a fixed R-version. These rely on MRAN [@revolutionanalyticsReproducibilityUsingFixed2019], a repository for R-Packages, which is fixed to the last date the R-version of the image was the most recent. Building upon these rocker-images researchers can build there own docker-images with the required R-packages. The rocker project also provides images which do include RStudio (`rocker/rstudio`), the `tidyverse` package (`rocker/tidyverse`) and the `rmarkdown` package with Latex (`rocker/verse`). Since the describes workflow relies on `rmarkdown` we suggest using the `rocker/verse` image (which also contains `rstudio` & `tidyverse`). These images are stored on [dockerhub](https://hub.docker.com) [@dockerinc.DockerHub2019].

The basic rocker images are extendable by a Dockerfile, e.g., the basis for docker image for this article is the following Dockerfile:

```
FROM rocker/verse:3.6.1
RUN install2.r --error --skipinstalled\
  pacman here pander
RUN installGithub.r\
  crsh/papaja benmarwick/wordcountaddin
WORKDIR /home/rstudio
```

The `FROM` statement specifies which docker image to use, in this case, the `rocker/verse` image with the tag 3.6.1 (referring to the R version 3.6.1). The `RUN` statement describes a command to execute, in this case, to run an R-script `install2.r` which is available on all rocker images, to install the packages `pacman`,  `here` & `pander`. A Dockerfile allows more than one `RUN` statement, executing any available command. Those `RUN` statements can install dependencies that are not an R package, e.g., other programming languages like python or Matlab. The `WORKDIR` statement is not strictly necessary but saves time spent writing the working directory. The command `docker build -t image-name` creates an image named `image-name` from the Dockerfile in the project. Following there are two principal ways to share a docker image, either by sharing the Dockerfile which created the image or by sharing the image itself e.g., through [dockerhub](https://hub.docker.com). While both ways guarantee a replicable computational environment, sharing the Dockerfile is more transparent, and git tracks changes to it.

There are two ways to use a rocker image. Either one starts with the `docker run` command. The first way is to run a command inside the container. These commands take the form:

```{bash, eval=FALSE}
docker run --rm -it <IMAGENAME> <COMMAND>
```

The `--rm` flag means to not save the state of the docker after the command finishes in an image. The `-it` flag means to accept inputs and return outputs to the terminal. Interacting with docker this way is especially useful when using `R` as a command because then you have access to the standard R-terminal.

```{bash, eval=FALSE}
docker run --rm -it reproducible-research R
```

![R-terminal running inside docker](Images/docker-r-terminal.png)

The second way is to supply no commands and to interact with the container via the webbrowser and the rstudio server instance that runs in it. For that you need to supply a password to log into rstudio server (`-e PASSWORD=<YOUR_PASS>`) and open a port (`-p 8787:8787`).

```{bash, eval=FALSE}
docker run -e PASSWORD=<YOUR_PASS> -p 8787:8787 image-name
```

The adress to connect to the rstudio server is your ip adress (or on linux also `localhost`) in this scheme: `<IPADRESS>:8787`. There is a fully functioning RStudio instance availible, that can be used exactly like one installed locally on the maschine.

None of the above containers can access files on your computer, instead a folder needs to be linked explizitly:

```{bash, eval=FALSE}
docker run -v /folder/on/your/computer:/folder/in/docker 
```

The main directory for RStudio inside docker is `/home/rstudio` so an apropriate command is:

```{bash, eval=FALSE}
docker run --rm -it -e PASSWORD=<YOUR_PASS> -p 8787:8787 -v /path/to/project:/home/rstudio reproducible-research
```

![RStudio running inside Docker](Images/docker-rstudio.png)

Since `docker`'s commands grow long and are tedius to type, we advocate to use some automatic way to generate them. Unfortunatly is the most comfortable way only availible on linux, which uses `make DOCKER=TRUE` together with a Makefile like the one used for that article.

```
projekt := $(shell basename `git rev-parse --show-toplevel`)
current_dir := $(shell pwd)
uid = $(shell id -u)

ifeq ($(DOCKER),TRUE)
	run:=docker run --rm --user $(uid) -v $(current_dir):/home/rstudio $(projekt)
	current_dir=/home/rstudio
endif

all: rr-flow.html

build: Dockerfile
	sudo docker build -t $(projekt) .

clean:
	Ruby/clean.rb
	rm -rf kitematic
.PHONY: clean

rr-flow.html: rr-flow.Rmd
	$(run) Rscript -e 'rmarkdown::render("$(current_dir)/$<")'
```

# Summary

The overarching goal of this paper was to provide an easy to use workflow, that allows confidence in reproducibility. This workflow can be almost unfailingly trusted to be replicable with the following commands:

```{bash, eval=FALSE}
git clone https://github.com/aaronpeikert/reproducible-research.git
cd reproducible-research
make build
make all DOCKER=TRUE
```

That is, it replicates a scientific report exactly without regard to the user, the operating system, the software, the timepoint or the version of the files. To that end, it relies on tools that have been the foundation of reliable software for years or in most cases, decades. On the way, it makes transparent how statistical results relate to the software that created them and enables, through that transparency, reuse by other researchers. 

Each tool reduces the number of ways things can go wrong. Dynamic reporting with `RMarkdown` fixes the relation between statistical report and statistical results; Version control with `git` fixes the version of the used files; Dependency management with `make` fixes relation of files and their processing; Containerization with `docker` fixes the software environment. This tightening of loose ends, we believe, does not restrict the researcher but enables her to operate on a solid basis to deliver sound research.

## Related approaches

! TODO

## Limitations

We are aware that implementing this workflow is not straightforward and the difficulty of its implementation may vary by platform. For example, already the installation of all tools is easier on POSIX-compatible platforms such as Unix, Linux, or macOS (but not Windows). However, once such a workflow is established as a default, it can be used with minimal changes to the familiar use of the R environment. It is even possible to move the entire development process to a docker environment.

In our own experience, it is often not possible to convince all co-authors to switch to a different document processing environment, such as RMarkdown. That is, we have experienced that after writing up the first draft in Rmarkdown, one must eventually switch to a dynamically generated Word-file that is from then on used as static file that is used as basis for multiple iterations among the co-authors. This means, that ideally, one would have to manually merge the final Word file back to the RMarkdown souce, which generally is only possible manually. But we believe that even if this final step does not happen that - as long as dynamically generated elements are not manipulated - ensuring the reproducibility of the analysis and the initial draft is a big step forward. A less elegant but potentially more practical workflow may involve the officer package (@gohel2019officer). The officer package allows the manipulation of  Word (.docx) and PowerPoint (*.pptx) documents, that is, given a formatted template file, one can dynamically paste images, tables and text into documents from R.

## Sharing reproducible workflows

How to best share a reproducible workflow? We believe that, ideally, a service provider should be found that guarantuees permanent and reliable hosting of the reproducible workflow, such as the Open Science Framework [@fosterOpenScienceFramework2017] or PsychData (citation needed). Second, to ensure that other users are legally able to benefit from the shared materials, authors must choose an appropriate license format. Typically, there is currently no single license that works for code, data, and media (such as text or figures). We encourage authors to choose appropriate license forms that do not hinder others from freely downloading, using, and moifying the shared workflows and materials while, at the same time, ensuring recognition for the time and effort invested in creating the workflow in the first place. In our experience, the Creative Commons license (CC-BY) is often appropriate for sharing texts, rmarkdown files, generated figures, and other media whereas scripts and any other computer code is often best shared according to the MIT license. Both licenses assure maximal freedom for future users while requiring the attribution of the original authors in derivative work. These licenses are also in line with the recommendations by the Reproducibile Research Standard (see @stoddenEnhancingReproducibilityComputational2016).

\newpage

# References

\begingroup
\setlength{\parindent}{-0.5in}
\setlength{\leftskip}{0.5in}

<div id = "refs"></div>
\endgroup
